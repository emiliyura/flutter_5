# Реализация навигации в мобильном приложении

## 1. Страничная навигация

Страничная навигация реализована с использованием стандартных методов Flutter Navigator. Для перехода между экранами используется класс Navigator, который управляет стеком маршрутов приложения.

Сначала реализуем страничную навигацию для открытия конкретных страниц с главного экрана при нажатии на соответствующие карточки (Рисунок 1).

**Рисунок 1 – Элементы для страничной навигации на главном экране**

Реализуем код для перехода на новую страницу с помощью Navigator.push в файле `lib/features/booking/screens/home_screen.dart` (Рисунок 2). При нажатии карточки текущий контекст открывает указанный виджет как новую страницу в стеке навигации.

**Рисунок 2 – Реализация добавления страницы через Navigator.push**

На самой странице необходимо предусмотреть логику возвращения назад. В реализации используется стандартный AppBar с кнопкой "Назад", которая вызывает метод Navigator.pop (Рисунок 3). При нажатии на иконку стрелки в AppBar происходит возврат на предыдущую страницу – страница удаляется из стека.

**Рисунок 3 – Реализация удаления страницы через Navigator.pop**

В данном случае навигация вертикальная, потому что мы можем добавить множество страниц в стек через Navigator.push, и, возвращаясь назад, будем поочередно в порядке стека возвращаться назад.

**Рисунок 4 – Отображение до перехода на экран номеров**

**Рисунок 5 – Отображение после перехода на экран номеров**

**Рисунок 6 – Отображение после возвращения назад**

## 2. Горизонтальная навигация

Для горизонтальной навигации в многошаговом процессе бронирования мы использовали метод `Navigator.pushReplacement` из Flutter SDK. Этот метод заменяет текущий маршрут в стеке навигации новым, что обеспечивает горизонтальную навигацию без накопления экранов в стеке.

### 2.1. Реализация горизонтальной навигации в процессе бронирования

Процесс бронирования состоит из трех шагов:
1. **Step1** - выбор дат заезда и выезда (`BookingStep1Screen`)
2. **Step2** - ввод данных гостя (`BookingStep2Screen`)
3. **Step3** - подтверждение бронирования (`BookingStep3Screen`)

Каждый шаг заменяет предыдущий в стеке навигации, что предотвращает накопление экранов и обеспечивает возможность возврата назад.

### 2.2. Переход с первого шага на второй

В файле `lib/features/booking/screens/booking_step1_screen.dart` реализован переход на второй шаг через метод `Navigator.pushReplacement`:

```dart
void _handleNext() {
  if (_checkIn == null || _checkOut == null) {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Выберите даты')),
    );
    return;
  }
  if (!_checkOut!.isAfter(_checkIn!)) {
    ScaffoldMessenger.of(context).showSnackBar(
      const SnackBar(content: Text('Дата выезда должна быть позже даты заезда')),
    );
    return;
  }
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(
      builder: (context) => BookingStep2Screen(
        room: widget.room,
        initialCheckIn: _checkIn!,
        initialCheckOut: _checkOut!,
      ),
    ),
  );
}
```

**Код находится в строках 51-74 файла `booking_step1_screen.dart`.**

### 2.3. Переход со второго шага на третий

В файле `lib/features/booking/screens/booking_step2_screen.dart` реализован переход на третий шаг:

```dart
void _handleNext() {
  if (!_formKey.currentState!.validate()) return;
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(
      builder: (context) => BookingStep3Screen(
        room: widget.room,
        guestName: _nameCtrl.text.trim(),
        checkIn: widget.initialCheckIn,
        checkOut: widget.initialCheckOut,
      ),
    ),
  );
}
```

**Код находится в строках 51-64 файла `booking_step2_screen.dart`.**

### 2.4. Возврат на предыдущий шаг

На втором шаге реализован возврат на первый шаг через `Navigator.pushReplacement` в файле `lib/features/booking/screens/booking_step2_screen.dart`:

```dart
void _goToStep1() {
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(
      builder: (context) => BookingStep1Screen(room: widget.room),
    ),
  );
}
```

**Код находится в строках 36-43 файла `booking_step2_screen.dart`.** Метод вызывается при нажатии на кнопку "Назад" в AppBar (строка 71) и кнопку "Отмена" (строка 115).

Аналогично, на третьем шаге реализован возврат на второй шаг в файле `lib/features/booking/screens/booking_step3_screen.dart`:

```dart
void _goToStep2(BuildContext context) {
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(
      builder: (context) => BookingStep2Screen(
        room: room,
        initialGuestName: guestName,
        initialCheckIn: checkIn,
        initialCheckOut: checkOut,
      ),
    ),
  );
}
```

**Код находится в строках 24-35 файла `booking_step3_screen.dart`.** Метод вызывается при нажатии на кнопку "Назад" в AppBar (строка 66) и кнопку "Отмена" (строка 123).

### 2.5. Завершение процесса бронирования

После подтверждения бронирования на третьем шаге происходит сохранение данных и переход на экран списка бронирований также через `Navigator.pushReplacement`:

```dart
void _saveBooking(BuildContext context) {
  final booking = Booking(
    id: DateTime.now().millisecondsSinceEpoch.toString(),
    roomId: room.id,
    guestName: guestName,
    checkIn: checkIn,
    checkOut: checkOut,
  );
  AppData.addBooking(booking);
  Navigator.pushReplacement(
    context,
    MaterialPageRoute(
      builder: (context) => Scaffold(
        appBar: AppBar(title: const Text('Мои бронирования')),
        body: const BookingListScreen(),
      ),
    ),
  );
}
```

**Код находится в строках 38-56 файла `booking_step3_screen.dart`.** Это обеспечивает, что пользователь не сможет вернуться к шагам бронирования после его завершения.

### 2.6. Боковое выдвижное меню (Drawer)

Дополнительно горизонтальная навигация реализована через боковое выдвижное меню (Drawer) в компоненте `RootShell` (файл `lib/app/root_shell.dart`). Меню содержит список пунктов навигации, который обеспечивает быстрый доступ к основным разделам приложения:

```dart
drawer: Drawer(
  child: ListView(
    padding: EdgeInsets.zero,
    children: [
      DrawerHeader(
        decoration: BoxDecoration(
          color: Theme.of(context).colorScheme.primary,
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisAlignment: MainAxisAlignment.end,
          children: [
            Icon(
              Icons.hotel,
              size: 48,
              color: Theme.of(context).colorScheme.onPrimary,
            ),
            const SizedBox(height: 8),
            Text(
              'Бронирование номеров',
              style: Theme.of(context).textTheme.headlineSmall?.copyWith(
                    color: Theme.of(context).colorScheme.onPrimary,
                  ),
            ),
          ],
        ),
      ),
      ...List.generate(_pages.length, (index) {
        final isSelected = _currentIndex == index;
        return ListTile(
          leading: Icon(
            _icons[index],
            color: isSelected
                ? Theme.of(context).colorScheme.primary
                : null,
          ),
          title: Text(_labels[index]),
          selected: isSelected,
          selectedTileColor: Theme.of(context).colorScheme.primaryContainer,
          onTap: () {
            Navigator.pop(context); // Закрыть drawer
            setState(() {
              _currentIndex = index;
            });
          },
        );
      }),
    ],
  ),
),
```

**Код находится в строках 46-94 файла `root_shell.dart`.** При выборе пункта меню происходит переключение между страницами приложения через изменение индекса `_currentIndex` (строки 86-89).

### 2.7. Горизонтальное расположение элементов на главном экране

Горизонтальное расположение элементов также используется на главном экране, где карточки статистики размещены в ряд с помощью виджета `Row`:

```dart
Row(
  children: [
    Expanded(
      child: _buildStatCard(
        context,
        'Всего номеров',
        totalRooms.toString(),
        Icons.hotel,
        Colors.blue,
      ),
    ),
    const SizedBox(width: 12),
    Expanded(
      child: _buildStatCard(
        context,
        'Доступно',
        availableRooms.toString(),
        Icons.check_circle,
        Colors.green,
      ),
    ),
    const SizedBox(width: 12),
    Expanded(
      child: _buildStatCard(
        context,
        'Бронирований',
        totalBookings.toString(),
        Icons.bookmark,
        Colors.orange,
      ),
    ),
  ],
),
```

**Код находится в строках 38-69 файла `home_screen.dart`.** Это позволяет компактно отобразить информацию о количестве номеров, доступных номерах и бронированиях.

## 3. Вертикальная навигация

Вертикальная навигация реализована на всех основных экранах приложения через прокручиваемые списки и контейнеры. Для реализации вертикальной прокрутки используются два основных подхода.

Первый подход – использование ListView.builder для динамического отображения списков элементов. Реализуем список номеров на экране RoomListScreen (Рисунок 14).

**Рисунок 14 – Реализация списка номеров через ListView.builder**

Аналогично реализуем список бронирований на экране BookingListScreen (Рисунок 15).

**Рисунок 15 – Реализация списка бронирований через ListView.builder**

Второй подход – использование SingleChildScrollView для прокрутки контента на экранах с формой или статическим содержимым. Реализуем прокрутку главного экрана с карточками быстрого доступа (Рисунок 16).

**Рисунок 16 – Реализация прокрутки через SingleChildScrollView на главном экране**

Экраны многошагового процесса бронирования также используют SingleChildScrollView для прокрутки форм (Рисунок 17).

**Рисунок 17 – Прокрутка формы бронирования через SingleChildScrollView**

Вертикальная навигация также реализована в боковом меню через ListView для отображения пунктов меню (Рисунок 18).

**Рисунок 18 – Вертикальный список пунктов меню в Drawer**

**Рисунок 19 – Отображение экрана списка номеров с вертикальной прокруткой**

**Рисунок 20 – Отображение экрана списка бронирований с вертикальной прокруткой**

## Заключение

В приложении реализован комбинированный подход к навигации, который обеспечивает удобство использования и интуитивно понятный интерфейс. Страничная навигация позволяет организовать переходы между экранами через стек Navigator, горизонтальная навигация обеспечивает быстрый доступ к разделам через боковое меню и замену экранов в многошаговых процессах, а вертикальная навигация реализована на всех экранах со списками и формами для удобного просмотра контента.

